#!/usr/bin/env bash

declare -F json >/dev/null 2>/dev/null || {
  #declare -r C_CR=$'\r' C_LF=$'\n'
  declare -rgx JSON_MIMETYPE="application/json"

  json_error(){
    >&2 echo -e "\033[31mJSON Error: $* at ${BASH_SOURCE[2]}:${BASH_LINENO[1]}\033[0m"
  }

  json_token(){
    JSON_TOKEN+=("$1")
    JSON_TOKEN_TYPE+=("$2")
    #echo "$1" "$2"
  }

  json_tokenize(){
    declare -gx JSON_TOKEN=() JSON_TOKEN_TYPE=() JSON_TOKEN_PREV="" JSON_ERR=() JSON_SRC="$1"
    declare -r x="$JSON_SRC"
    declare -ri n=${#x}
    declare -i i=0 k=0
    while ((i<n)); do
      k=$i && c="${x:k:1}"
      case "$c" in
        [[:space:]]) # whitespace
          while ((++i<n)); do
            c="${x:i:1}"
            [[ "$c" != [[:space:]] ]] && break
            #[ "$c" == $C_LF ] &&
          done
          json_token "${x:k:((i-k))}" space
          ;;
        '"') # strings
          while ((++i<n)); do [ "${x:i:1}" == "$c" ] && [ "${x:((i-1)):1}" != "\\" ] && break; done
          [ "$i" = "$n" ] && { json_error "unclosed string literal" && return 2; }
          json_token "${x:k:((++i-k))}" string
          ;;
        -|[[:digit:]]) # numbers
          if [[ "$c" == - ]] && [[ "${x:((i+1)):1}" != [[:digit:]] ]]; then
            json_token - code && ((++i))
          else
            while ((++i<n)); do [[ "${x:i:1}" = [[:digit:]] ]] || break; done
            if [ "${x:i:1}" = . ]; then
              while ((++i<n)); do [[ "${x:i:1}" = [[:digit:]] ]] || break; done
            fi
            json_token "${x:k:((i-k))}" number
          fi
          ;;
        _|[[:alpha:]]) # literals
          while ((++i<n)); do [[ "${x:i:1}" = @([[:alpha:]]|_) ]] || break; done
          json_token "${x:k:((i-k))}" kw
          ;;
        *) # single-char token
          json_token "$c" code && ((++i))
          ;;
      esac
    done
  }

  json(){
    declare -gx JSON_URL=""
    if url_type "$1" >/dev/null; then
      case "$url_type" in
        file) json_tokenize "$(< "$url_path" )";;
        http*) json_tokenize "$( curl "$1" 2>/dev/null )";;
      esac
    else
      json_tokenize "$1"
    fi
    declare -ri n=${#JSON_TOKEN[@]}
    declare -i i=0 k=0
    while ((i<n)); do
      echo ${JSON_TOKEN[i]}
      ((++i))
    done
  }

  # @return a) string, scheme of URL (or "file" if filename exists)
  #         b) if multiple params are given returns 0 only if type of first param matches one of the provided others
  # @param: URL or filename
  # @param(s): URL types to check for match
  # @effect sets global variables: url_type, url_data, url_user, url_pass, url_host, url_port, url_path, url_query
  # @alias is_url parse_url
  # @usage `if url_type "$url" file http ftp; then ...`
  url_type(){
    local t && declare -gx url_type="" url_user="" url_pass="" url_path="" url_data="$1" url_query="" && shift
    if [[ "$1" == *?* ]]; then
      url_data="${1%%$'?'*}"
      url_query="${1#*$'?'}"
    fi
    if [[ "$url_data" == *://* ]]; then
      url_type="${url_data%%:*}" && url_type="${url_type,,}"
      url_data="${url_data:((${#url_type}+3))}"
    elif [ -e "$url_data" ]; then
      url_type="file"
    fi
    case "$url_type" in
      "") return 1;;
      file)
        url_path="$url_data";;
      http|https|ftp|sftp)
        url_path="/${url_data#*\/}"
        url_host="${url_data%%\/*}"
        if [[ "$url_host" == *@* ]]; then
          url_user="${url_host%%@*}"
          if [[ "$url_user" == *:* ]]; then
            url_pass="${url_user#*:}"
            url_user="${url_user%%:*}"
          fi
          url_host="${url_host#*@}"
          if [[ "$url_host" == *:* ]]; then
            url_port="${url_port#*:}"
          fi
        fi
        ;;
    esac
    if [ "$#" -eq 0 ]; then
      echo "$url_type"
    else
      for t; do [ "${t,,}" == "$url_type" ] && return; done
      return 2
    fi
  }
}

json test.json
#json "https://dummyjson.com/test"
#json_tokenize '{"foo":"bar"}'

